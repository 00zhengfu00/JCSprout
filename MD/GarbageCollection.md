# 垃圾回收

> 垃圾回收主要思考三件事情:

- 哪种内存需要回收？
- 什么时候回收？
- 怎么回收？

## 对象是否存活

### 引用计数法

这是一种非常简单易理解的回收算法。每当有一个地方引用一个对象的时候则在引用计数器上 +1，当失效的时候就 -1，无论什么时候计数器为 0 的时候则认为该对象死亡可以回收了。

这种算法虽然简单高效，但是却无法解决**循环引用**的问题，因此 Java 虚拟机并没有采用这种算法。

### 可达性分析算法

可达性算法是通过一个称为 `GC Roots` 的对象像下搜索，整个搜索路径就称为引用链，当一个对象到 `GC Roots` 没有任何引用链 `JVM` 就认为该对象是可以被回收的。

![](https://ws3.sinaimg.cn/large/006tNc79gy1fmwqi5mv1jj30e407kmxm.jpg)

如图:Object1、2、3、4 都是存活的对象，而 Object5、6、7都是可回收对象。

可以用作 `GC-Roots` 的对象有:

- 方法区中静态变量所引用的对象。
- 虚拟机栈中所引用的对象。

## 垃圾回收算法

### 标记-清除算法

标记清楚算法分为两个步骤，标记和清除。
首选将需要回收的对象标记起来，然后统一清除。但是存在两个主要的问题:
- 标记和清除的效率都不高。
- 清楚之后容易出现不连续内存，当需要分配一个较大内存时就不得不需要进行一次垃圾回收。

标记清除过程如下:
![](https://ws3.sinaimg.cn/large/006tNc79gy1fmz99ai1n3j30fj08qdgc.jpg)

### 复制算法

复制算法是将内存划分为两块大小相等的区域，每次使用时都只用其中一块区域，当发生垃圾回收时会将使用存活的对象全部复制到未使用的区域，然后对之前的区域进行全部回收。

这样简单高效，而且还不存在标记清除算法中的内存碎片问题，但就是有点浪费内存。

> 在新生代会使用该算法。

新生代中分为一个 `Eden` 区和两个 `Survivor` 区。通常两个区域的比例是 `8:1:1` ，使用时会用到 `Eden` 去和其中一个 `Survivor` 区。当发生回收时则会将还存活的对象从 Eden ，Survivor 区拷贝到另一个 Survivor 区。当该区域内存也不足时候则会使用分配担保使用永久代来存放内存。

复制算法过程：
![](https://ws3.sinaimg.cn/large/006tNc79gy1fmzavlf4enj30fj08qt9b.jpg)



### 分代回收
